const { CompileMessage, DebugCompileMessage } = require('../base/messages');
const { analyseCsnPath, traverseQuery } = require('../model/csnRefs');

/**
 * @param {XSN.Model | CSN.Model} model
 * @param {any}       msg
 * @param {XSN.Location|CSN.Location|CSN.Path} location
 * @param {string}    severity
 * @param {string}    message_id
 * @param {boolean}   useDebugMsg
 */
function buildMessage(model, msg, location, severity, message_id, useDebugMsg){
  let semanticLocation = undefined;
  if(Array.isArray(location)){
    semanticLocation = location;
    validateSemanticLocation(semanticLocation);
    location = searchForLocation(semanticLocation);
  }
  severity =  severity || msg._severity;
  return (useDebugMsg)
    ? new DebugCompileMessage(location, msg, severity, message_id, beautifySemanticLocation(semanticLocation))
    : new CompileMessage(location, msg, severity, message_id, beautifySemanticLocation(semanticLocation));

  /** @param {CSN.Path} semanticLocation */
  function searchForLocation(semanticLocation){
    let last_location = null; // Don't display a location if we cannot find one!
    /** @type {object} */
    let currentThing = model;
    for(const step of semanticLocation){
      if(!currentThing){
        return last_location;
      }
      currentThing = currentThing[step];

      if(currentThing && currentThing.$location){
        last_location = currentThing.$location;
      }
    }

    return last_location;
  }

  /** @param {CSN.Path} semanticLocation */
  function validateSemanticLocation(semanticLocation){

    if (semanticLocation.length === 0){
      throw new Error('An empty semantic location was supplied, this should not happen!');
    }

    if (semanticLocation[0] !== 'definitions'){
      throw new Error('Semantic locations must start with "definitions", found: ' + semanticLocation[0]);
    }

    if (semanticLocation.length === 1){
      throw new Error('Semantic locations must at least point to an artifact!');
    }

    return true;
  }

  /** @param {CSN.Path} csnPath */
  function beautifySemanticLocation(csnPath){
    if(!csnPath){
      return csnPath;
    }
    return constructSemanticLocation([...csnPath], model);
  }
}


function constructSemanticLocation(csnPath, model) {
  const csnDictionaries = [
    'args', 'params', 'enum', 'mixin', 'elements', 'actions', 'definitions',
  ];
  
  let { query } = analyseCsnPath(
    csnPath,
    model
  );

  // remove definitions
  csnPath.shift();
  const artName = csnPath.shift();
  let currentThing  = model.definitions[artName];
  let result = ((currentThing && currentThing.kind) ? currentThing.kind : 'artifact') + ':' + quoted(artName);

  if(query) {
    query = queryDepth(currentThing.query, query);
  }
  let elements = [];
  let inCsnDict, inElement, inAction, inParam, inKeys, inRef, inEnum, inQuery, inColumn, inMixin, inItems  = false;
  for(const [index, step] of csnPath.entries()){
    currentThing = currentThing[step];
    if(csnDictionaries.includes(step) && !inCsnDict) {
      inCsnDict = true;
      switch (step) {
        case 'elements':
          if(!inElement) {
            inElement = true;
          }
          break;
        case 'actions':
          inAction = true;
          break;
        case 'params':
          inParam = true;
          break;
        case 'enum':
          inElement = false;
          inEnum = true;
          break
        case 'mixin':
          inMixin = true;
          inQuery = false;
          break;
        default:
          if (inElement) {
            // close element
            result += element();
            inElement = false;
          }
      }
    }
    else if( inQuery ){
      if(step === 'SELECT') {
        if(!csnPath[index + 1]) {
          result += select();
        } else if (['from', 'where', 'groupBy', 'having', 'orderBy', 'limit', 'offset'].includes(csnPath[index + 1]) && !csnPath[index + 2]) {
          let clause = csnPath[index + 1];
          result += select();
          result += '/' + clause;
        }
      } 
      else if(step === 'columns'){
        result += select();
        result += '/column';
        inColumn = true;
        inQuery = false;
      }
    }
    else if( inMixin ) {
      if(step === 'on') {
        result += '/on';
        break;
      } else {
        result += selectAndMixin(step);
      }
    }
    else if(inEnum) {
      result += elementAndEnum(step);
    }
    else if(!inElement && step === 'query'){
      inQuery = true;
    } 
    else if(inElement && step === 'keys') {
      // close element
      result +=  element() + '/key';
      inElement = false;
      inKeys = true;
    }
    else if(inElement && step === 'on') {
      // close element
      result +=  element() + '/on';
      inElement = false;
      break;
    }
    else if(inElement && step === 'items') {
      // this is an element called items
      if(csnPath[index - 1] === 'elements' && elements[elements.length - 1] !== 'elements'){
        elements.push(step);
      }
      else {
        inElement = false;
        inItems = true;
      }  
    }
    else if(inElement && step === 'elements') {
      // this is an element called elements
      if(csnPath[index - 1] === 'elements'){
        elements.push(step);
      }
    }
    else if(inItems && step === 'elements') {
      inElement = true;
      inItems = false;
    }
    else if( inKeys || inColumn){
      if (typeof step === 'number') {
        if(currentThing.as) {
          result += ':' + quoted(currentThing.as);
        }else {
          result += inRef ? ':' + quoted(currentThing) : currentThing.ref ? ':' + quoted(currentThing.ref.join('.')) : '';
        }
        break;
      } 
      if( step === 'ref'){
        inRef = true;
      }
    }
    else if(inAction && step === 'returns') {
      result += '/' + step;
      break;
    } 
    else if(inCsnDict) {
      if (inElement)
        elements.push(step);
      else if(inParam){
        result += param(step);
      } else if(inAction){
        result += func(step);
      }
      inCsnDict = false;
    }
  }
  if( inElement ) result += element();
  if( inItems ) result +=  element() + '/items';
  return result;

  function select() {
    let s = '/select';
    s += query.isOnlySelect ? '' : ':' + query.depth;
    return s;
  }
  function selectAndMixin(name) {
    return `${select()}/mixin:${quoted(name)}`;
  }
  function element() {
    return `/element:${quoted(elements.join('.'))}`;
  }
  function param(name) {
    return `/param:${quoted(name)}`; 
  }
  function func(name) {
    return `/function:${quoted(name)}`; 
  }
  function elementAndEnum(name) {
    return `${element()}/enum:${quoted(name)}`;
  }

  /**
   * Traverse rootQuery until targetQuery is found and count the depth,
   * check if targetQuery is only select in entity.
   */
  function queryDepth (rootQuery, targetQuery) {
    let targetQueryDepth = 1;
    let totalQueryDepth = 0;

    let isFound = false;
    traverseQuery(rootQuery, null, function countSelect(q, select) {
      if( select ) totalQueryDepth += 1;
      if( select && !isFound) targetQueryDepth += 1;
      if(q === targetQuery) isFound = true;
      
    });
    return { depth: targetQueryDepth, isOnlySelect: totalQueryDepth === 1 };
  }
}


function quoted( name ) {
  return (name) ? '"' + name.replace( /"/g, '""' ) + '"' : '<?>'; // sync ";
}


module.exports = buildMessage;

